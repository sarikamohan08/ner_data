import pdfplumber
import openai
import time

openai.api_key = "YOUR_OPENAI_API_KEY"
EMBED_MODEL = "text-embedding-3-small"

def extract_table_rows_with_above_line(pdf_path):
    rows = []

    with pdfplumber.open(pdf_path) as pdf:
        for page_num, page in enumerate(pdf.pages):
            tables = page.find_tables()
            words = page.extract_words(x_tolerance=3, y_tolerance=3, keep_blank_chars=False, use_text_flow=True)

            # Group words by lines using their y0 values
            line_map = {}
            for w in words:
                y = round(w['top'], 1)
                if y not in line_map:
                    line_map[y] = []
                line_map[y].append(w['text'])

            sorted_lines = sorted(line_map.items(), key=lambda kv: -kv[0])  # top-to-bottom
            line_texts = [(y, ' '.join(txts)) for y, txts in sorted_lines]

            for table_index, table in enumerate(tables):
                try:
                    table_data = table.extract()
                    if not table_data or len(table_data) < 2:
                        continue

                    # Get top Y of first table row (not header)
                    table_top_y = table.bbox[1]  # ymin

                    # Find closest line above this Y
                    above_line_text = ""
                    for y, text in line_texts:
                        if y > table_top_y:
                            above_line_text = text
                            break

                    header = [h.strip() if h else "" for h in table_data[0]]
                    for row in table_data[1:]:
                        if len(row) != len(header):
                            continue
                        row_dict = {
                            (header[i] or "").strip(): (row[i] or "").strip()
                            for i in range(len(header))
                        }
                        formatted = ", ".join(f"{k}: {v}" for k, v in row_dict.items() if v)
                        full_text = f"[Page {page_num+1} Table {table_index+1}] {above_line_text} ‚Äî {formatted}"
                        rows.append(full_text)
                except Exception as e:
                    print(f"‚ö†Ô∏è Table extraction failed: {e}")
                    continue

    return rows

def extract_page_text(pdf_path):
    texts = []
    with pdfplumber.open(pdf_path) as pdf:
        for page_num, page in enumerate(pdf.pages):
            text = page.extract_text()
            if text:
                cleaned = ' '.join(line.strip() for line in text.splitlines() if line.strip())
                texts.append(f"[Page {page_num+1} Text] {cleaned}")
    return texts

def embed_texts(texts, model=EMBED_MODEL):
    vectors = []
    for i, text in enumerate(texts):
        try:
            print(f"üîπ Embedding {i+1}/{len(texts)}")
            response = openai.embeddings.create(input=text, model=model)
            vectors.append(response.data[0].embedding)
        except Exception as e:
            print(f"‚ùå Failed embedding {i+1}: {e}")
            vectors.append([])
        time.sleep(0.5)
    return vectors

def save_texts(texts, filename="texts.txt"):
    with open(filename, 'w') as f:
        for t in texts:
            f.write(t + '\n')

def save_embeddings(vectors, filename="embeddings.txt"):
    with open(filename, 'w') as f:
        for vec in vectors:
            if vec:
                f.write(' '.join(map(str, vec)) + '\n')

if __name__ == "__main__":
    pdf_path = "your_file.pdf"  # Replace with your PDF

    print("üìÑ Extracting text...")
    regular_texts = extract_page_text(pdf_path)

    print("üìä Extracting table rows with above-line heading...")
    table_texts = extract_table_rows_with_above_line(pdf_path)

    all_texts = regular_texts + table_texts
    print(f"üì¶ Total chunks: {len(all_texts)}")

    print("üß† Embedding...")
    embeddings = embed_texts(all_texts)

    print("üíæ Saving...")
    save_texts(all_texts)
    save_embeddings(embeddings)

    print("‚úÖ Done! Table rows now include the text line directly above them.")
