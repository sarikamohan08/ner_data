import pdfplumber
import openai
import time

openai.api_key = "YOUR_OPENAI_API_KEY"
EMBED_MODEL = "text-embedding-3-small"

def extract_table_rows_with_headings(pdf_path):
    rows = []
    with pdfplumber.open(pdf_path) as pdf:
        for page_num, page in enumerate(pdf.pages):
            lines = page.extract_text().splitlines() if page.extract_text() else []
            cleaned_lines = [line.strip() for line in lines if line.strip()]
            tables = page.extract_tables()

            line_index = 0
            for table_index, table in enumerate(tables):
                if not table or len(table) < 2:
                    continue  # skip empty or malformed tables

                # Guess heading line: last non-empty line before the table
                heading_line = cleaned_lines[line_index - 1] if line_index > 0 else ""
                header = [h.strip() if h else "" for h in table[0]]

                for row in table[1:]:
                    if len(row) != len(header):
                        continue
                    row_dict = {
                        (header[i] or "").strip(): (row[i] or "").strip()
                        for i in range(len(header))
                    }
                    formatted = ", ".join(f"{k}: {v}" for k, v in row_dict.items() if v)
                    full_row = f"[Page {page_num + 1} Table {table_index + 1}] {heading_line} ‚Äî {formatted}"
                    rows.append(full_row)

                # move line_index to after the table, if possible
                line_index = min(len(cleaned_lines), line_index + 1)
    return rows

def extract_regular_text(pdf_path):
    texts = []
    with pdfplumber.open(pdf_path) as pdf:
        for page_num, page in enumerate(pdf.pages):
            text = page.extract_text()
            if text:
                lines = [line.strip() for line in text.splitlines() if line.strip()]
                if lines:
                    joined = ' '.join(lines)
                    texts.append(f"[Page {page_num + 1} Text] {joined}")
    return texts

def embed_texts(texts, model=EMBED_MODEL):
    vectors = []
    for i, text in enumerate(texts):
        try:
            print(f"üîπ Embedding {i+1}/{len(texts)}")
            response = openai.embeddings.create(input=text, model=model)
            vectors.append(response.data[0].embedding)
        except Exception as e:
            print(f"‚ùå Failed embedding {i+1}: {e}")
            vectors.append([])
        time.sleep(0.5)
    return vectors

def save_texts(texts, filename="texts.txt"):
    with open(filename, 'w') as f:
        for t in texts:
            f.write(t + '\n')

def save_embeddings(vectors, filename="embeddings.txt"):
    with open(filename, 'w') as f:
        for vec in vectors:
            if vec:
                f.write(' '.join(map(str, vec)) + '\n')

if __name__ == "__main__":
    pdf_path = "your_file.pdf"  # Replace with your file

    print("üìã Extracting regular text...")
    text_blocks = extract_regular_text(pdf_path)

    print("üìä Extracting table rows with headings...")
    table_rows = extract_table_rows_with_headings(pdf_path)

    all_texts = text_blocks + table_rows
    print(f"üì¶ Total chunks to embed: {len(all_texts)}")

    print("üß† Generating embeddings...")
    embeddings = embed_texts(all_texts)

    print("üíæ Saving results...")
    save_texts(all_texts)
    save_embeddings(embeddings)

    print("\n‚úÖ Done! Table rows now include nearby heading text.")
